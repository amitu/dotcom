-- my-ds.page: Journal

-- ds.h1: jupylite_duckdb

25th Apr 2023

I am generally having mind blown with WASM. First there was [`pyiodide`]
(/pyiodide/) which let's you run Python in browser or any wasm capable backend.
Why does it matter? Imagine if we can run `Python` without installing it on the
end users machine, say end user only installs `fastn` binary, and it internally
contains Python via wasm! And unlike regular Python, where there is no safety,
it can do anything, this will be completely caged Python, where scripts you
download will have controlled CPU/RAM/network/file access.

And then there is [jupyterlite](https://jupyterlite.readthedocs.io/en/latest/)
which lets you run Jupyter Notebook in browser.

And while Python is good, what about database? Supabase people have already
gotten PostgreSQL running in browser, and now there is duckdb also. PostgreSQL
is more of a demo, but duckdb in browser, and SQLite in browser for that
matter, and minus the browser part, these on wasm server, read `fastn` can be
totally game changing.

Why DuckDB and not SQLite? DuckDB is column oriented, so more analytics
workloads instead of row oriented SQLite. Also DuckDB is more strongly typed,
SQLite is not so strict.

-- ds.h1: `miette` vs `ariadne`

Been working on a sort of re-architecture of `fastn`, and it's kind of making
me re-write/refactor significant portion of `fastn`, and during this I stumbled
upon an opportunity to improve the error messages. I love the [error messages of
Elm](https://elm-lang.org/news/compiler-errors-for-humans) or Rust. And have
always wanted to implement something like that in `fastn`.

We are creating very fine grained error types to represent exact error, so we
have the basic machinery in place. Now we have to do actual error printing. We
can do that from scratch, and get complete control over the messages, or we use
some existing crate and save ourselves some bother.

Came across these two crates, [`meitte`](https://github.com/zkat/miette) and
[`ariadne`](https://github.com/zesterer/ariadne). The two have very similar
stats, `meitte` gets more downloads than `ariadne` but not enough to be
undisputed winner.

The tldr of why I am leaning towards `ariadne` is 1. `ariadne` is written as a
companion library for [chumsky](https://github.com/zesterer/chumsky/), a crate
to help "write expressive, high-performance parsers with ease", so while we are
not using `chumsky` and have hand written the parser, we may consider using
`chumsky` because it has a feature that our parser lacks, "powerful error
recovery", `chumsky` parsers keep going as much as they can and do not bail at
first error message. 2. `meitte` seems to have higher download count because it
is too much tied with `std::error::Error`, people get error and error stack,
and need a good way to print that error stack, and this is where `meitte` comes
in, where as `ariadne` is written for programming language parser related error
messages. Most people are not writing programming language parsers, so it has
less usage in the wild.


-- ds.h1: TIL: Text Fragment Linking

[Scroll to text fragment](https://stackoverflow.com/questions/62161819)

You can create a link like `https://fastn.com/#:~:text=Build%20anything&text=hello`
and when someone visits the page the browser will scroll to that location, and
it will highlight the selection. [Try
it](https://fastn.com/#:~:text=Build%20anything&text=hello).

You can also use `#:~:text=<first word>,<last word>` to highlight entire para.
And you can use `:target` pseudo-class to explicitly style the selection.

You can [opt out of this feature](https://github.com/WICG/scroll-to-text-fragment#opting-out) as well for your document.

Works in Safari as well!

-- ds.h1: Restarting Journal-ing

I used to do a lot of journaling for ftd and fpm way back. Starting again.
Can't wait for us to implement mixed visibility for documents, so I can note
down my private entries as well in this file. As of now only public stuff can
go here.

-- ds.h1: Optional Closing

So there was a problem in fastn design that I have been struggling with since
almost 2 year now, and Arpita kind of solved it. The funniest thing is the
solution was kind of a bug, which now is going to become one of the coolest
feature.

The problem: including content defined in document into another. I want this to
be easy to do, and the syntax must be easy, and clean.

Let's say we have a document like this:

-- ds.code:
lang: ftd

\-- ds.page: hello world

\-- ds.h1: this is a section

This is some content, which technically belongs to the h1. This
para itself is not a problem as it gets passed to `ds.h1` as body.

\-- ds.code: but consider this code for example
lang: md

This is a sibling of the `ds.h1`

\-- ds.markdown:

And this para.

\-- ds.h2: why even this belongs to the h1

\-- ds.h1: but not this one

\-- end: ds.page

-- ds.markdown:

So, if someone wants to include just the first `ds.h1` content, including all
its "logical" children, meaning all the content till the next `ds.h1` or end of
the container, how do they do it?

The naive way to do this in `fastn` right now is to create a component.

-- ds.code:
lang: ftd

\-- ds.page: hello world

\-- component the-section:  ;; <hl>

\-- ftd.column:  ;; <hl>

\-- ds.h1: this is a section

This is some content, which technically belongs to the h1. This
para itself is not a problem as it gets passed to `ds.h1` as body.

\-- ds.code: but consider this code for example
lang: md

This is a sibling of the `ds.h1`

\-- ds.markdown:

And this para.

\-- ds.h2: why even this belongs to the h1

\-- end: ds.column  ;; <hl>

\-- end: the-section  ;; <hl>

\-- the-section:  ;; <hl>

\-- ds.h1: but not this one

\-- end: ds.page


-- ds.markdown:

Not fond of all those lines I added. Adding `ftd.column` is completely noisy, we
had to add the column because a component body can contain only single ftd
element. The code is even buggy, we have to give full width to the column and
make sure the column inherits the gap property of the `ds.page`. But this we
can solve, we are planning to allow a component contain more than one top level
components.

We will still have the create component line, the end component line, and the
invocation line, as if we only define the component and not use it, it's
content will not show up in the page. So three lines.

What I have shown is also currently not possible as a component can not be
defined while we are in the middle of another component (`ds.page` in this
case), so we have to move the component definition before or after `ds.page`
invocation. This problem will also go with time.

If we want to use this in another document we have to do:

-- ds.code:
lang: ftd

\-- import: fastn.io/hello-world  ;; <hl>

\-- ds.page: my new page

\-- hello-world.the-section:  ;; <hl>

\-- end: ds.page


-- ds.markdown:

This is not that bad. Just two lines. But this too has a bit of a problem, what
if we move the definition of `the-section` to another document? It's not a big
problem, but this is very common referencing problem, referencing different
definitions, images etc defined in other part of site is a common problem, and
if we have a lot of references set up moving content around becomes a problem.

This is why sphinx, latex etc allow you to reference by an id alone, without
worrying about where the id is defined.

-- ds.h2: A Failed Solution

What if we auto created the "component" based on the `id` property:

-- ds.code:
lang: ftd

\-- ds.page: hello world

\-- ds.h1: this is a section
id: the-section

This is some content, which technically belongs to the h1. This
para itself is not a problem as it gets passed to `ds.h1` as body.

\-- ds.code: but consider this code for example
lang: md

This is a sibling of the `ds.h1`

\-- ds.markdown:

And this para.

\-- ds.h2: why even this belongs to the h1

\-- ds.h1: but not this one

\-- end: ds.page

-- ds.markdown:

And make it such that this worked still.

-- ds.code:
lang: ftd

\-- import: fastn.io/hello-world  ;; <hl>

\-- ds.page: my new page

\-- hello-world.the-section:  ;; <hl>

\-- end: ds.page

-- ds.markdown:

Wait, how would we know what all to include?

-- ds.code:
lang: ftd

\-- ds.page: hello world

\-- ds.h1: this is a section  ;; <hl>
id: the-section  ;; <hl>

This is some content, which technically belongs to the h1. This  ;; <hl>
para itself is not a problem as it gets passed to `ds.h1` as body.  ;; <hl>

\-- ds.code: but consider this code for example
lang: md

This is a sibling of the `ds.h1`

-- ds.markdown:

These much is obvious, we look for the section with matching id, and we include
it. How do we tell ftd to include till the next h1?

We had a fancy solution for this. We even implemented in 0.2 version of ftd. We
called it [auto renesting or something](https://github.com/fastn-stack/fastn/blob/df63ce17115ba2c27c060345280eb1eb920e697d/ftd/src/ftd2021/ui.rs#L1758).
What we did was allow you to specify a "region" on any component, eg for h1 you
can say its region is "heading-1" or something, and we scan the document, and
every sibling that proceeds a component with a region is automatically nested
under that component, till we reach a section with same or higher region.

We removed this feature soon, as it caused some issues with the structure of the
generated DOM. We could have fixed it, but I found the feature a bit too tricky
to implement, explain etc. It was a bit magical. And required careful setup.

-- ds.h2: The Final Solution

So the problem is how do we know till what point does the `ds.h1` extend to? And
we do not want to rely on auto-renesting. What if we allowed the `-- end:
ds.h1`? This is a standard way to end things.

And this is where we realised there is a bug. See, `ds.h1` is defined to accept
children, meaning `-- end: ds.h1` is actually allowed, and if you use it, the
enclosed content will become children of `ds.h1`, but if you do not include
`-- end: ds.h1`, the proceeding sections are simply siblings.

This "the `-- end: <container-component>` for any container-component is
optional" felt like a bug to me. "It's a container, it must use `-- end:`" was
my thinking. But this bug basically lets you omit the `-- end:` if you do not
want to pass any children to the container, and often we do not want to. I guess
this is what Aprita was thinking when she impelmented this bug/feature.

After speaking with her I have come around to seeing things from her point of
view and I consider it a feature now.

-- ds.h2: Coming Back To The ID

So what can we do about the "reference not breaking of content is moved"
problem?

-- ds.code:
lang: ftd

\-- import: fastn.io/-/refs  ;; <hl>

\-- ds.page: my new page

\-- refs.the-section:  ;; <hl>

\-- end: ds.page

-- ds.markdown:

We basically create a special module, `fastn.io/-/refs` where we embed all the
`id`, after converting each section with `id` to a virtual component. And now
the definition of `the-section` can be moved to any document and the above
document will keep on working.

-- ds.h2: Abstract Vs Full

Now that we have to setup `ds.h1` with children, we can define the `ds.h1`,
without children, with just the caption, headers and body, as the "abstract" of
the `ds.h1`. We can generate it by rendering it by temporarily removing the
children.

-- ds.code:
lang: ftd

\-- import: fastn.io/-/refs  ;; <hl>

;; to get just the abstract
\-- refs.the-section:

;; to get the full version
\-- refs.the-section.full:

-- ds.markdown:

This allows us to either include just the abstract or the full version. We can
also use the "abstract" version for auto generated glossary of the site, or for
search results. We can also use the abstract for if the reference is just
linked instead of being transcluded in the current document, in this case we
can show the abstract as a tooltop, like how Wikipedia does.

-- ds.h2: External Referencing And Citation

We can import `/-/refs` belonging to other packages as well, and this was we can
refer to things published on other website. We can also put extra data on the
section so we can do citation as well:

-- ds.code:
lang: rs

\-- import: einstien.com/-/refs as erefs  ;; <hl>

;; to get just the abstract
\-- erefs.theory-of-relativity:

\-- citation.credits: erefs.theory-of-relativity.cite  <hl>

-- ds.h1: Nix Actions In Github

Came across [this blog post](https://determinate.systems/posts/nix-github-actions)
about using nix instead of Github's custom action framework for installing
dependencies.

Has listed good reasons to consider nix, many actions may not exist, or many
actions may exist for the same task and you have to now research, or maybe the
actions do not support all the platforms you are interested in, and finally you
can not run the exact dependency used by your action locally.

With nix you work in the same shell day to day, and the exact same versions run
on Github.

-- ds.h1: Nushell

Came across [some project](https://github.com/nix-systems/current-system/blob/main/flake.nix)
using [`nuenv`](https://github.com/DeterminateSystems/nuenv), which lets you
write `nu` scripts instead of bash in your `nix` files. Made me curious and
checked out `nu` once again.

It is quite close to PowerShell, you pipe around tables and records instead of
text. Has support for dataframe for example. And is a immutable, function
programming language to write your shell scripts/functions in. And you can
write your [plugins in Rust](https://github.com/nushell/nushell/blob/main/crates/nu_plugin_example/src/main.rs).
Plugins basically communicate with nushell via stdin/out using JSON or
messagepack.

-- ds.h1: CLI Idea - curler

So I learnt about [`curl -d` pattern](til/#curl-d) today. What if we had a cli
to assist with this:

-- ds.code:
lang: sh

curl https://api.my-site.com/follow -d $(cat ~/.my-site.session) -d username=amitu

Say we have ~/.curler.json.

-- ds.code:
lang: json

{
    "my-site": {
        "endpoint": "https://api.my-site.com/",
        "session": "~/.my-site.session"
    }
}

-- ds.code:
lang: sh

curler mysite follow --username=amitu

-- ds.markdown:

We can even create site specific executables.

-- ds.code: this is in your `.zshrc`
lang: sh

curler rehash
PATH=$PATH:~/.curler/bin

-- ds.markdown:

`curler rehash` will read `~/.curler.json` and create binaries for every site
in `~/.curler/bin` so you can do:

-- ds.code:
lang: sh

mysite follow amitu

-- ds.markdown:

We have not given specified username here, as follow takes only one argument,
username. We can create a spec for this:

-- ds.code: `curler.json`
lang: json

{
    "my-site": {
        "endpoint": "https://api.my-site.com/",
        "session": "~/.my-site.session",
        "commands": {
            "follow": {
                "about": "Follow your friend.",
                "api": "/follow",
                "arguments": {
                    "username": {
                        "type": "string",
                        "required": true,
                        "positional": true,
                        "about": "The username to follow"
                    }
                }
            }
        }
    }
}

-- ds.markdown:

The spec json can define the entire cli arguments, with sub commands etc. We
can put basic validations. We can also put TUI UI creation, so you can just call
the `my-site` command, and it shows you a list of options about what all can you
do.

Ideally the spec should be itself retrivable via the API, so we do not have to
store them. If the spec allows validations or some computation or IO that can
cause potential security issue, we can do hash pinning, the or maybe the specs
are distributed as part of some community, so you can look at the ratings,
reviews etc to decide if you want to trust it or not.

How to construct the UI? Can we use `fastn` for this? Further there is the
question of response. Do we just show the JSON? For many cases a syntax
highlighted json would be enough. But if we had the power of fastn we can do
much more.


-- end: my-ds.page
